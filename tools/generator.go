package tools

import (
	"flag"
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

// Generator generate cqrs proxy and provider
type Generator struct {
	GenProxy   bool
	PackageDir string
	Filter     *regexp.Regexp
}

// NewGenerator creates new generator
func NewGenerator() *Generator {
	proxyCmd := flag.NewFlagSet("proxy", flag.ExitOnError)
	proxyDirFlag := proxyCmd.String("dir", ".", "Directory containing input package")
	proxyNameFlag := proxyCmd.String("name", "", "Regex filtering interfaces to be included")

	providerCmd := flag.NewFlagSet("provider", flag.ExitOnError)
	providerDirFlag := providerCmd.String("dir", ".", "Directory containing input package")
	providerNameFlag := providerCmd.String("name", "", "Regex filtering interfaces to be included")

	if len(os.Args) < 2 {
		fmt.Println("expected 'proxy' or 'provider' subcommands")
		os.Exit(1)
	}

	generator := &Generator{}

	switch os.Args[1] {
	case "proxy":
		proxyCmd.Parse(os.Args[2:])
		generator.GenProxy = true
		generator.PackageDir = *proxyDirFlag

		if *proxyNameFlag != "" {
			regex, _ := regexp.Compile(*proxyNameFlag)
			generator.Filter = regex
		}
	case "provider":
		providerCmd.Parse(os.Args[2:])
		generator.GenProxy = false
		generator.PackageDir = *providerDirFlag

		if *providerNameFlag != "" {
			regex, _ := regexp.Compile(*providerNameFlag)
			generator.Filter = regex
		}
	default:
		fmt.Println("expected 'proxy' or 'provider' subcommands")
		os.Exit(1)
	}

	return generator
}

// Param argument or return name and type of a inputMethod
type Param struct {
	Name      string
	Type      string
	Package   string
	IsPointer bool
}

// Method information struct
type Method struct {
	Name    string
	KeyName string
	Args    []*Param
	Rets    []*Param
}

// ObjInfo interface information
type ObjInfo struct {
	PackageName     string
	FullPackageName string
	Name            string
	Methods         []*Method
}

// GenerateProxy generates proxy
func (gen *Generator) GenerateProxy(infObj *ObjInfo) *jen.File {
	rpcImport := "github.com/pongsatt/go-rpc"

	f := jen.NewFile(infObj.PackageName)
	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	name := infObj.Name
	strctName := name + "Proxy"

	// struct
	f.Commentf("%s struct", strctName)
	f.Type().Id(strctName).Struct(jen.Id("client").Op("*").Qual(rpcImport, "RequestReplyClient"))

	// new func
	f.Commentf("%s creates new instance", "New"+strctName)
	f.Func().Id("New" + strctName).
		Params(jen.Id("client").Op("*").
			Qual(rpcImport, "RequestReplyClient")).
		Op("*").Id(strctName).Block(
		jen.Return(jen.Op("&").Id(strctName).Values(jen.Id("client"))),
	)

	// struct methods
	for _, inputMethod := range infObj.Methods {
		f.Commentf("%s func", inputMethod.Name)
		methodGen := f.Func().Params(
			jen.Id("proxy").Id("*" + strctName),
		).Id(inputMethod.Name)

		genArgs := make([]jen.Code, 0)
		genArgTypes := make([]jen.Code, 0)
		genArgNames := make([]jen.Code, 0)

		for _, arg := range inputMethod.Args {
			argType := jen.Empty()

			if arg.IsPointer {
				argType = jen.Op("*")
			}

			argType.Qual(arg.Package, arg.Type)

			genArgs = append(genArgs, jen.Id(arg.Name).Add(argType))
			genArgTypes = append(genArgTypes, argType)
			genArgNames = append(genArgNames, jen.Id(arg.Name))
		}

		methodGen.Params(genArgs...)

		genResults := make([]jen.Code, 0)

		for _, ret := range inputMethod.Rets {
			genResults = append(genResults, jen.Id(ret.Type))
		}

		methodGen.Parens(jen.List(genResults...))

		// request key
		keyStmt := jen.Lit("")
		if inputMethod.KeyName != "" {
			keyStmt = jen.Id(inputMethod.KeyName)
		}

		methodGen.Block(
			jen.Var().Id("f").Func().Params(jen.List(genArgTypes...)).Parens(jen.List(genResults...)),
			jen.Qual(rpcImport, "Call").Call(
				jen.Lit(inputMethod.Name),
				jen.Op("&").Id("f"),
				jen.Func().
					Params(jen.Id("reqBytes").Id("[]byte")).
					Parens(jen.List(jen.Id("[]byte"), jen.Id("error"))).Block(
					jen.Return(jen.Id("proxy.client.Request").Call(keyStmt, jen.Id("reqBytes"))),
				)),
			jen.Return(jen.Id("f").Call(genArgNames...)),
		)
	}

	return f
}

// GenerateProvider generate provider
func (gen *Generator) GenerateProvider(pkgName string, objInfo *ObjInfo) *jen.File {
	rpcImport := "github.com/pongsatt/go-rpc"

	f := jen.NewFile(pkgName)
	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	name := objInfo.Name
	var providerID string

	for i, v := range name {
		providerID = string(unicode.ToLower(v)) + name[i+1:]
		break
	}

	fnName := "New" + name + "Provider"

	// new func
	genSwitchCases := make([]jen.Code, 0)

	for _, method := range objInfo.Methods {
		genSwitchCases = append(genSwitchCases, jen.Case(
			jen.Lit(method.Name),
		).Return(
			jen.Qual(rpcImport, "Execute").Call(jen.Id("req"), jen.Id(providerID).Dot(method.Name)),
		),
		)
	}

	f.Commentf("%s creates new instance", fnName)
	f.Func().Id(fnName).Params(
		jen.Id("client").
			Op("*").
			Qual(rpcImport, "RequestReplyClient"),
		jen.Id(providerID).
			Op(
				"*").
			Id(name),
	).
		Params(jen.Id("error")).Block(
		jen.Return(jen.Id("client.SubscribeRequest").Call(
			jen.Func().Params(jen.Id("reqBytes").Id("[]byte")).
				Parens(jen.List(jen.Id("[]byte"), jen.Id("error"))).
				Block(
					jen.List(jen.Id("req"), jen.Id("err")).
						Op(":=").
						Qual(rpcImport, "Decode").Call(jen.Id("reqBytes")),
					jen.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Nil(), jen.Id("err")),
					),
					jen.Switch(jen.Id("req.Name")).Block(genSwitchCases...),
					jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(
						jen.Lit("method '%s' is not supported"),
						jen.Id("req.Name"),
					)),
				),
		),
		))

	return f
}

// WriteFile generates file
func (gen *Generator) WriteFile(f *jen.File) {
	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := filepath.Join(gen.PackageDir, baseFilename+"_gen.go")
	fmt.Printf("writing file %s\n", targetFilename)
	f.Save(targetFilename)
}

func getKeyNameFromType(name string, t types.Type) string {
	switch v := t.(type) {
	case *types.Basic:
		switch v.Kind() {
		case types.String:
			if strings.HasSuffix(strings.ToLower(name), "id") {
				return name
			}
		}
	case *types.Named:
		return getKeyNameFromType(name, v.Underlying())
	case *types.Struct:
		for i := 0; i < v.NumFields(); i++ {
			field := v.Field(i)

			if strings.HasSuffix(strings.ToLower(field.Name()), "id") {
				return name + "." + field.Name()
			}
		}
	case *types.Pointer:
		return getKeyNameFromType(name, v.Elem())
	}
	return ""
}
func getKeyName(arg *types.Var) string {
	name := arg.Name()

	return getKeyNameFromType(name, arg.Type())
}

func findKeyName(sig *types.Signature) string {
	if sig.Params().Len() > 0 {
		arg0 := sig.Params().At(0)
		keyName := getKeyName(arg0)

		if keyName != "" {
			return keyName
		}
	}

	return ""
}

func getType(t types.Type) (pckName string, typeName string, isPointer bool) {
	switch v := t.(type) {
	case *types.Named:
		typeName := v.Obj()
		if typeName.Pkg() != nil {
			return typeName.Pkg().Path(), typeName.Name(), false
		}
		return "", typeName.Name(), false
	case *types.Pointer:
		pckName, typeName, _ = getType(v.Elem())
		return pckName, typeName, true
	}
	return "", t.String(), false
}

func getParam(v *types.Var, fullPackageName string) *Param {
	argPckName, argTypeName, isPointer := getType(v.Type())

	if argPckName == fullPackageName {
		argPckName = ""
	}

	return &Param{
		Name:      v.Name(),
		Type:      argTypeName,
		Package:   argPckName,
		IsPointer: isPointer,
	}
}

// LoadPackage load package information
func (gen *Generator) LoadPackage() *packages.Package {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(cfg, gen.PackageDir)
	if err != nil {
		panic(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

// ListInterfaces to generate proxy
func (gen *Generator) ListInterfaces(pkg *packages.Package) []types.Object {
	infObjs := make([]types.Object, 0)
	regex := gen.Filter

	for _, name := range pkg.Types.Scope().Names() {
		obj := pkg.Types.Scope().Lookup(name)

		_, ok := obj.Type().Underlying().(*types.Interface)
		if ok && (regex == nil || regex.MatchString(name)) {
			infObjs = append(infObjs, obj)
		}
	}

	return infObjs
}

// ListStructs list struct to generate provider
func (gen *Generator) ListStructs(pkg *packages.Package) []types.Object {
	regex := gen.Filter
	objs := make([]types.Object, 0)

	for _, name := range pkg.Types.Scope().Names() {
		obj := pkg.Types.Scope().Lookup(name)

		_, ok := obj.Type().Underlying().(*types.Struct)
		if ok && (regex == nil || regex.MatchString(name)) {
			objs = append(objs, obj)
		}
	}

	return objs
}

// GetInfObj get interface object information
func (gen *Generator) GetInfObj(pkgName string, inputObj types.Object) *ObjInfo {
	infObj := &ObjInfo{
		PackageName:     inputObj.Pkg().Name(),
		FullPackageName: inputObj.Pkg().Path(),
		Name:            inputObj.Name(),
		Methods:         make([]*Method, 0),
	}

	inf, _ := inputObj.Type().Underlying().(*types.Interface)

	// struct methods
	for i := 0; i < inf.NumMethods(); i++ {
		inputMethod := inf.Method(i)

		method := &Method{
			Name: inputMethod.Name(),
			Args: make([]*Param, 0),
			Rets: make([]*Param, 0),
		}

		infObj.Methods = append(infObj.Methods, method)

		sig, _ := inputMethod.Type().Underlying().(*types.Signature)

		method.KeyName = findKeyName(sig)

		for argi := 0; argi < sig.Params().Len(); argi++ {
			argInput := sig.Params().At(argi)
			method.Args = append(method.Args, getParam(argInput, infObj.FullPackageName))
		}

		results := sig.Results()
		for ri := 0; ri < results.Len(); ri++ {
			inputResult := results.At(ri)
			method.Rets = append(method.Rets, getParam(inputResult, infObj.FullPackageName))
		}
	}

	return infObj
}

// GetStructObj get struct info object
func (gen *Generator) GetStructObj(pkgName string, inputObj types.Object) *ObjInfo {
	objInfo := &ObjInfo{
		PackageName:     inputObj.Pkg().Name(),
		FullPackageName: inputObj.Pkg().Path(),
		Name:            inputObj.Name(),
		Methods:         make([]*Method, 0),
	}

	strct, _ := inputObj.Type().(*types.Named)

	// struct methods
	for i := 0; i < strct.NumMethods(); i++ {
		inputMethod := strct.Method(i)

		method := &Method{
			Name: inputMethod.Name(),
			Args: make([]*Param, 0),
			Rets: make([]*Param, 0),
		}

		objInfo.Methods = append(objInfo.Methods, method)

		sig, _ := inputMethod.Type().Underlying().(*types.Signature)

		method.KeyName = findKeyName(sig)

		for argi := 0; argi < sig.Params().Len(); argi++ {
			argInput := sig.Params().At(argi)
			method.Args = append(method.Args, getParam(argInput, objInfo.FullPackageName))
		}

		results := sig.Results()
		for ri := 0; ri < results.Len(); ri++ {
			inputResult := results.At(ri)
			method.Rets = append(method.Rets, getParam(inputResult, objInfo.FullPackageName))
		}
	}

	return objInfo
}
